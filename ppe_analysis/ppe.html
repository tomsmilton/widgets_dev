<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPE Fit Factor Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: none;
            width: calc(100% - 40px);
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 30px;
            overflow-x: hidden;
            box-sizing: border-box;
        }
        .header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        h1 {
            color: #333;
            margin: 0;
            font-size: 2.5rem;
        }
        .header-controls {
            display: flex;
            gap: 10px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .select-all-btn {
            background-color: #17a2b8;
            color: white;
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 8px;
            transition: background-color 0.3s;
        }
        .select-all-btn:hover {
            background-color: #138496;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        label {
            font-weight: bold;
            margin-bottom: 8px;
            color: #555;
            font-size: 14px;
        }
        select, input[type="number"] {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            width: 100%;
            max-width: 180px;
            background-color: white;
            min-height: 100px;
        }
        select[multiple] {
            min-height: 120px;
        }
        select option:checked {
            background-color: #4CAF50;
            color: white;
        }
        select:focus, input[type="number"]:focus {
            border-color: #4CAF50;
            outline: none;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
            margin: 2px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .btn-secondary {
            background-color: #6c757d;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        .btn-danger {
            background-color: #dc3545;
        }
        .btn-danger:hover {
            background-color: #c82333;
        }
        .btn-info {
            background-color: #17a2b8;
        }
        .btn-info:hover {
            background-color: #138496;
        }
        .btn-success {
            background-color: #28a745;
        }
        .btn-success:hover {
            background-color: #218838;
        }
        .plots-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
            position: relative;
        }
        .chart-container {
            position: relative;
            height: auto;
            min-height: 500px;
            background-color: #fafafa;
            border-radius: 8px;
            padding: 20px;
            border: 2px solid #e9ecef;
            width: 100%;
            box-sizing: border-box;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .chart-title {
            font-weight: bold;
            color: #333;
        }
        .chart-controls {
            display: flex;
            gap: 5px;
        }
        .chart-canvas-container {
            position: relative;
            height: 400px;
            margin-bottom: 15px;
        }
        .hidden {
            display: none;
        }
        .empty-state-plus {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            background-color: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 12px;
            margin: 40px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #6c757d;
            font-size: 48px;
            font-weight: bold;
        }
        .empty-state-plus:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            color: #495057;
            transform: scale(1.02);
        }
        .plots-plus-button {
            width: 100%;
            padding: 20px;
            margin-top: 30px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .plots-plus-button:hover {
            background-color: #5a6268;
        }
        .plots-plus-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(3px);
        }
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }
        .modal-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 30px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }
        .modal-close:hover {
            background-color: #f8f9fa;
            color: #333;
        }
        .modal-section {
            margin-bottom: 25px;
        }
        .modal-section h4 {
            margin: 0 0 15px 0;
            color: #555;
            font-size: 1.1em;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .current-lines-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 10px;
            background-color: #f8f9fa;
        }
        .current-line-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin: 4px 0;
            background-color: white;
            border-radius: 6px;
            border-left: 4px solid;
            font-size: 14px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            flex-wrap: wrap;
            gap: 8px;
        }
        .current-line-label {
            flex-grow: 1;
            margin-right: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 200px;
        }
        .current-line-remove {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            flex-shrink: 0;
            transition: background-color 0.3s;
        }
        .current-line-remove:hover {
            background-color: #c82333;
        }
        .empty-lines {
            text-align: center;
            color: #999;
            font-style: italic;
            padding: 20px;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .stat-item {
            background-color: #e8f5e8;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            min-width: 120px;
        }
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #2e7d32;
        }
        .stat-label {
            color: #666;
            font-size: 0.9em;
        }
        .plot-stats {
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
            margin-top: 15px;
            max-height: 120px;
            overflow-y: auto;
        }
        .stats-row {
            display: flex;
            justify-content: space-around;
            gap: 10px;
            flex-wrap: wrap;
        }
        .plot-stats .stat-item {
            background-color: #e8f5e8;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            min-width: 80px;
            flex: 1;
        }
        .plot-stats .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #2e7d32;
        }
        .plot-stats .stat-label {
            color: #666;
            font-size: 0.8em;
        }
        
        /* Main content area with plots */
        .plots-and-add-container {
            display: block;
            margin-top: 20px;
            width: 100%;
        }
        
        /* Individual plot with add button */
        .plot-with-add {
            display: block;
            margin-bottom: 20px;
        }
        
        /* Config buttons styles */
        .config-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .config-button:hover {
            background-color: #5a6268;
        }
        
        /* Keyboard key styling */
        kbd {
            background-color: #f9f9f9;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-shadow: 0 1px 1px rgba(0,0,0,0.2);
            color: #333;
            display: inline-block;
            font-family: Arial, sans-serif;
            font-size: 0.85em;
            font-weight: bold;
            line-height: 1;
            padding: 2px 4px;
            white-space: nowrap;
        }
        
        /* Per-series statistics styles */
        .stats-header {
            text-align: center;
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
        }
        .series-stats-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 80px;
            overflow-y: auto;
        }
        .series-stat-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background-color: white;
            border-radius: 6px;
            border-left: 4px solid;
            font-size: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .series-label {
            flex: 1;
            font-weight: bold;
            margin-right: 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 120px;
        }
        .series-stats {
            display: flex;
            gap: 8px;
            font-size: 11px;
        }
        .series-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 45px;
        }
        .series-stat-value {
            font-weight: bold;
            color: #2e7d32;
        }
        .series-stat-label {
            color: #666;
            font-size: 9px;
        }
        .no-series {
            text-align: center;
            color: #999;
            font-style: italic;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-section">
            <h1>PPE Fit Factor Analysis</h1>
            <div class="header-controls">
                <button id="saveConfigButton" class="config-button btn-info" onclick="saveConfig()" title="Save Current Configuration">
                    üíæ Save Config
                </button>
                <button id="loadConfigButton" class="config-button btn-secondary" onclick="triggerLoadConfig()" title="Load Configuration from File">
                    üìÅ Load Config
                </button>
                <input type="file" id="configFileInput" accept=".yml,.yaml" style="display: none;" onchange="loadConfig(event)">
            </div>
        </div>
        
        <!-- Empty state plus button (shown when no plots) -->
        <div id="emptyStatePlus" class="empty-state-plus" onclick="openCreateModal()" title="Create New Plot">
            +
        </div>
        
        <!-- Plots and vertical add button container (shown when there are plots) -->
        <div id="plotsAndAddContainer" class="plots-and-add-container hidden">
            <div id="plotsContainer" class="plots-container">
                <!-- Charts will be added here dynamically -->
            </div>
        </div>
        
        <!-- Plus button below plots (shown when there are plots) -->
        <button id="plotsPlusButton" class="plots-plus-button hidden" onclick="openCreateModal()" title="Create New Plot">
            <span>+</span> Add New Plot
        </button>
        
        <!-- Edit Plot Modal -->
        <div id="editModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title" id="modalTitle">Create New Plot</div>
                    <button class="modal-close" onclick="closeEditModal()">&times;</button>
                </div>
                
                <div class="modal-section" id="currentLinesSection" style="display: none;">
                    <h4>Current Lines</h4>
                    <div class="current-lines-list" id="currentLinesList">
                        <div class="empty-lines">No lines in this plot</div>
                    </div>
                </div>
                
                <div class="modal-section">
                    <h4 id="addLinesTitle">Add Lines to Plot</h4>
                    <div style="background-color: #e8f4fd; padding: 12px; border-radius: 6px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                        <p style="margin: 0; font-size: 14px; color: #1976D2;">
                            <strong>üí° How to select multiple items:</strong><br>
                            ‚Ä¢ Hold <kbd>Ctrl</kbd> (Windows/Linux) or <kbd>Cmd</kbd> (Mac) and click to select multiple individual items<br>
                            ‚Ä¢ Use "Select All" buttons for quick selection of all options<br>
                            ‚Ä¢ You can mix and match selections from different categories
                        </p>
                    </div>
                    <div class="controls">
                        <div class="control-group">
                            <button class="select-all-btn" onclick="selectAllPersons()">Select All Persons</button>
                            <label for="modalPersonSelect">Person:</label>
                            <select id="modalPersonSelect" multiple>
                                <option value="">Select Person</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <button class="select-all-btn" onclick="selectAllMasks()">Select All Masks</button>
                            <label for="modalMaskSelect">Mask:</label>
                            <select id="modalMaskSelect" multiple>
                                <option value="">Select Mask</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <button class="select-all-btn" onclick="selectAllActions()">Select All Actions</button>
                            <label for="modalActionSelect">Action:</label>
                            <select id="modalActionSelect" multiple>
                                <option value="">Select Action</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="control-row">
                        <button id="modalActionButton" onclick="handleModalAction()" disabled>Create Plot</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let charts = [];
        let currentChartIndex = 0;
        let availableFiles = [];
        let chartColors = [
            '#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336',
            '#00BCD4', '#FFEB3B', '#795548', '#607D8B', '#E91E63'
        ];
        
        // Parse filename to extract person, mask, and action
        function parseFilename(filename) {
            const name = filename.replace('.csv', '');
            const parts = name.split('_');
            
            if (parts.length >= 4) {
                const person = parts[0];
                const mask = parts[1].replace('.', ''); // Remove the period from mask
                const action = parts[3]; // Action is the 4th part after splitting by underscore
                return { person, mask, action };
            }
            return null;
        }
        
        // Get list of available CSV files
        async function getAvailableFiles() {
            try {
                // Fetch the directory listing from the Data folder
                const response = await fetch('Data/');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const html = await response.text();
                
                // Parse the HTML to extract CSV file names
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const links = doc.querySelectorAll('a');
                
                const files = [];
                links.forEach(link => {
                    const href = link.getAttribute('href');
                    if (href && href.endsWith('.csv')) {
                        files.push(href);
                    }
                });
                
                console.log('Found CSV files:', files);
                
                return files.map(file => {
                    const parsed = parseFilename(file);
                    return {
                        filename: file,
                        ...parsed
                    };
                }).filter(item => item.person);
                
            } catch (error) {
                console.error('Error fetching file list:', error);
                
                // Fallback to hardcoded list if directory listing fails
                console.log('Falling back to hardcoded file list');
                const fallbackFiles = [
                    'Lydia_Versaflo._Action_a.csv',
                    'Lydia_Versaflo._Action_b.csv',
                    'Lydia_Versaflo._Action_c.csv',
                    'Lydia_Versaflo._Action_d.csv',
                    'Lydia_Versaflo._Action_f.csv',
                    'Lydia_Versaflo._Action_g.csv',
                    'Lydia_Versaflo._Action_h.csv',
                    'Lydia_Versaflo._Action_i.csv',
                    'Lydia_3M62006035._Action_a.csv',
                    'Lydia_3M62006035._Action_b.csv',
                    'Lydia_3M62006035._Action_c.csv',
                    'Lydia_3M62006035._Action_d.csv',
                    'Lydia_3M62006035._Action_f.csv',
                    'Lydia_3M62006035._Action_g.csv',
                    'Lydia_3M62006035._Action_h.csv',
                    'Lydia_3M62006035._Action_i.csv',
                    'Lydia_3M6200P100._Action_a.csv',
                    'Lydia_3M6200P100._Action_b.csv',
                    'Lydia_3M6200P100._Action_c.csv',
                    'Lydia_3M6200P100._Action_d.csv',
                    'Lydia_3M6200P100._Action_f.csv',
                    'Lydia_3M6200P100._Action_g.csv',
                    'Lydia_3M6200P100._Action_h.csv',
                    'Lydia_3M6200P100._Action_i.csv',
                    'Lydia_EMProML._Action_a.csv',
                    'Lydia_EMProML._Action_b.csv',
                    'Lydia_EMProML._Action_c.csv',
                    'Lydia_EMProML._Action_d.csv',
                    'Lydia_EMProML._Action_f.csv',
                    'Lydia_EMProML._Action_g.csv',
                    'Lydia_EMProML._Action_h.csv',
                    'Lydia_EMProML._Action_i.csv',
                    'Lydia_EMProML._Action_j.csv',
                    'Lydia_EMProS._Action_a.csv',
                    'Lydia_EMProS._Action_b.csv',
                    'Lydia_EMProS._Action_c.csv',
                    'Lydia_EMProS._Action_d.csv',
                    'Lydia_EMProS._Action_f.csv',
                    'Lydia_EMProS._Action_g.csv',
                    'Lydia_EMProS._Action_h.csv',
                    'Lydia_EMProS._Action_i.csv'
                ];
                
                return fallbackFiles.map(file => {
                    const parsed = parseFilename(file);
                    return {
                        filename: file,
                        ...parsed
                    };
                }).filter(item => item.person);
            }
        }
        
        // Load and parse CSV data
        async function loadCSVData(filename) {
            try {
                console.log(`Loading CSV file: ${filename}`);
                const response = await fetch(`Data/${filename}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                console.log(`CSV text length: ${csvText.length}, first 200 chars:`, csvText.substring(0, 200));
                
                return new Promise((resolve, reject) => {
                    Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            console.log(`Papa Parse results for ${filename}:`, {
                                data: results.data.length,
                                errors: results.errors,
                                meta: results.meta
                            });
                            
                            if (results.errors.length > 0) {
                                console.warn(`Papa Parse errors for ${filename}:`, results.errors);
                            }
                            
                            resolve(results.data);
                        },
                        error: function(error) {
                            console.error(`Papa Parse error for ${filename}:`, error);
                            reject(error);
                        }
                    });
                });
            } catch (error) {
                console.error('Error loading CSV:', error);
                throw error;
            }
        }
        
        // Calculate statistics
        function calculateStats(fitFactorValues) {
            const validValues = fitFactorValues.filter(v => !isNaN(v) && v !== null);
            
            if (validValues.length === 0) return null;
            
            const mean = validValues.reduce((sum, val) => sum + val, 0) / validValues.length;
            const max = Math.max(...validValues);
            const min = Math.min(...validValues);
            
            return {
                mean: mean.toFixed(2),
                max: max.toFixed(2),
                min: min.toFixed(2),
                count: validValues.length
            };
        }
        
        // Update statistics display
        function updateStats(stats) {
            const statsContainer = document.getElementById('statsContainer');
            if (stats) {
                document.getElementById('meanValue').textContent = stats.mean;
                document.getElementById('maxValue').textContent = stats.max;
                document.getElementById('minValue').textContent = stats.min;
                document.getElementById('dataPoints').textContent = stats.count;
                statsContainer.style.display = 'flex';
            } else {
                statsContainer.style.display = 'none';
            }
        }
        
        // Create a new chart container
        function createChartContainer(index, totalCharts = null) {
            const plotsContainer = document.getElementById('plotsContainer');
            
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.id = `chartContainer${index}`;
            
            chartContainer.innerHTML = `
                <div class="chart-header">
                    <div class="chart-title">Plot ${index + 1}</div>
                    <div class="chart-controls">
                        <button class="btn-info" onclick="openFullScreen(${index})" title="Open in Full Screen">‚õ∂</button>
                        <button class="btn-success" onclick="downloadChart(${index})" title="Download Chart">‚¨á</button>
                        <button class="btn-secondary" onclick="openEditModal(${index})">Edit</button>
                        <button class="btn-danger" onclick="removeChart(${index})">Remove</button>
                    </div>
                </div>
                <div class="chart-canvas-container">
                    <canvas id="chart${index}"></canvas>
                </div>
                <div class="plot-stats" id="plotStats${index}">
                    <div class="stats-header">
                        <strong>Statistics per Series</strong>
                    </div>
                    <div class="series-stats-container" id="seriesStats${index}">
                        <div class="no-series">No data series</div>
                    </div>
                </div>
            `;
            
            plotsContainer.appendChild(chartContainer);
            return chartContainer;
        }
        
        // Modal functionality
        let editingChartIndex = -1;
        let isCreatingNewPlot = false;
        
        function openCreateModal() {
            isCreatingNewPlot = true;
            editingChartIndex = -1;
            
            const modal = document.getElementById('editModal');
            const modalTitle = document.getElementById('modalTitle');
            const currentLinesSection = document.getElementById('currentLinesSection');
            const addLinesTitle = document.getElementById('addLinesTitle');
            const modalActionButton = document.getElementById('modalActionButton');
            
            modalTitle.textContent = 'Create New Plot';
            addLinesTitle.textContent = 'Add Lines to Plot';
            modalActionButton.textContent = 'Create Plot';
            currentLinesSection.style.display = 'none';
            
            // Populate modal dropdowns
            populateModalDropdowns();
            
            // Show modal
            modal.style.display = 'block';
            
            // Clear modal selections
            clearModalSelections();
            
            // Update button state
            checkModalButtons();
        }
        
        function openEditModal(chartIndex) {
            isCreatingNewPlot = false;
            editingChartIndex = chartIndex;
            
            const modal = document.getElementById('editModal');
            const modalTitle = document.getElementById('modalTitle');
            const currentLinesSection = document.getElementById('currentLinesSection');
            const addLinesTitle = document.getElementById('addLinesTitle');
            const modalActionButton = document.getElementById('modalActionButton');
            
            modalTitle.textContent = `Edit Plot ${chartIndex + 1}`;
            addLinesTitle.textContent = 'Add New Lines';
            modalActionButton.textContent = 'Add Lines to Plot';
            currentLinesSection.style.display = 'block';
            
            // Populate modal dropdowns
            populateModalDropdowns();
            
            // Update current lines display
            updateModalLinesList();
            
            // Show modal
            modal.style.display = 'block';
            
            // Clear modal selections
            clearModalSelections();
            
            // Update button state
            checkModalButtons();
        }
        
        function closeEditModal() {
            const modal = document.getElementById('editModal');
            modal.style.display = 'none';
            editingChartIndex = -1;
            isCreatingNewPlot = false;
        }
        
        function handleModalAction() {
            if (isCreatingNewPlot) {
                createNewPlotFromModal();
            } else {
                addLineToEditingPlot();
            }
        }
        
        async function createNewPlotFromModal() {
            try {
                const persons = getModalSelectedValues('modalPersonSelect');
                const masks = getModalSelectedValues('modalMaskSelect');
                const actions = getModalSelectedValues('modalActionSelect');
                
                if (persons.length === 0 || masks.length === 0 || actions.length === 0) {
                    alert('Please select at least one option from each dropdown');
                    return;
                }
                
                // Create the datasets for the new chart
                const datasets = [];
                let maxLength = 0;
                
                // Create datasets for all combinations
                for (const person of persons) {
                    for (const mask of masks) {
                        for (const action of actions) {
                            const file = availableFiles.find(f => 
                                f.person === person && f.mask === mask && f.action === action
                            );
                            
                            if (file) {
                                try {
                                    const data = await loadCSVData(file.filename);
                                    console.log(`Loaded data for ${file.filename}:`, data.slice(0, 3)); // Debug: log first 3 rows
                                    
                                    // More robust data extraction
                                    const fitFactorValues = data.map(row => {
                                        // Handle different possible column names
                                        let fitFactorValue = row.FitFactor || row['Fit Factor'] || row.fitfactor;
                                        
                                        // Convert to number, handling various input types
                                        if (typeof fitFactorValue === 'string') {
                                            fitFactorValue = fitFactorValue.trim();
                                        }
                                        
                                        const numValue = parseFloat(fitFactorValue);
                                        return isNaN(numValue) ? null : numValue;
                                    }).filter(val => val !== null);
                                    
                                    console.log(`Fit factor values for ${file.filename}:`, fitFactorValues.slice(0, 10)); // Debug: log first 10 values
                                    
                                    if (fitFactorValues.length > 0) {
                                        maxLength = Math.max(maxLength, fitFactorValues.length);
                                        
                                        const colorIndex = datasets.length % chartColors.length;
                                        const color = chartColors[colorIndex];
                                        
                                        // Add main dataset
                                        datasets.push({
                                            label: `${person} / ${mask} / Action ${action}`,
                                            data: fitFactorValues,
                                            borderColor: color,
                                            backgroundColor: color + '20',
                                            borderWidth: 2,
                                            fill: false,
                                            tension: 0.1
                                        });
                                    }
                                } catch (error) {
                                    console.error(`Error loading data for ${person}/${mask}/${action}:`, error);
                                }
                            }
                        }
                    }
                }
                
                if (datasets.length === 0) {
                    alert('No valid data found for the selected combinations');
                    return;
                }
                
                // Create timestamps based on the longest dataset
                const timestamps = Array.from({length: maxLength}, (_, i) => i + 1);
                
                // Get the new chart index (always append to end)
                const newChartIndex = charts.length;
                
                // Create chart container first
                createChartContainer(newChartIndex);
                
                // Calculate actual data range needed
                let actualMaxLength = 0;
                datasets.forEach(dataset => {
                    if (dataset.data.length > actualMaxLength) {
                        actualMaxLength = dataset.data.length;
                    }
                });
                
                // Create labels only for the actual data range
                const actualTimestamps = Array.from({length: actualMaxLength}, (_, i) => i + 1);
                
                // Create chart configuration
                const chartConfig = {
                    type: 'line',
                    data: {
                        labels: actualTimestamps,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Data Point'
                                }
                            },
                            y: {
                                type: 'logarithmic',
                                title: {
                                    display: true,
                                    text: 'Fit Factor (Log Scale)'
                                },
                                min: 1,
                                ticks: {
                                    callback: function(value, index, values) {
                                        if (value === 1 || value === 10 || value === 100 || value === 1000) {
                                            return value;
                                        }
                                        if (value >= 1 && value < 10) {
                                            return Math.round(value * 10) / 10;
                                        }
                                        if (value >= 10 && value < 100) {
                                            return Math.round(value);
                                        }
                                        return value;
                                    }
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `PPE Fit Factor Analysis - Plot ${newChartIndex + 1}`,
                                font: {
                                    size: 16
                                }
                            },
                            legend: {
                                display: true
                            }
                        }
                    }
                };
                
                // Create the Chart.js instance
                const ctx = document.getElementById(`chart${newChartIndex}`).getContext('2d');
                const chart = new Chart(ctx, chartConfig);
                
                // Add the chart to the array
                charts.push(chart);
                
                // Update plot statistics
                updatePlotStats(newChartIndex);
                
                // Update plus button visibility
                updatePlusButtonVisibility();
                
                // Close modal
                closeEditModal();
                
            } catch (error) {
                console.error('Error creating plot:', error);
                alert('Error creating plot: ' + error.message);
            }
        }
        
        // Rebuild all chart containers and charts
        function rebuildAllCharts() {
            const plotsContainer = document.getElementById('plotsContainer');
            plotsContainer.innerHTML = '';
            
            // Store the chart data before destroying charts
            const chartDataArray = charts.map(chart => {
                if (chart && chart.data) {
                    return {
                        datasets: JSON.parse(JSON.stringify(chart.data.datasets)),
                        labels: [...chart.data.labels]
                    };
                }
                return null;
            }).filter(data => data !== null);
            
            // Destroy existing charts
            charts.forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            
            // Clear the charts array
            charts = [];
            
            // Recreate charts with preserved data
            chartDataArray.forEach((chartData, index) => {
                // Create container
                createChartContainer(index, chartDataArray.length);
                
                // Create chart with fresh configuration
                const ctx = document.getElementById(`chart${index}`).getContext('2d');
                
                // Create fresh chart configuration
                const chartConfig = {
                    type: 'line',
                    data: {
                        labels: chartData.labels,
                        datasets: chartData.datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Data Point'
                                }
                            },
                            y: {
                                type: 'logarithmic',
                                title: {
                                    display: true,
                                    text: 'Fit Factor (Log Scale)'
                                },
                                min: 1,
                                ticks: {
                                    callback: function(value, index, values) {
                                        if (value === 1 || value === 10 || value === 100 || value === 1000) {
                                            return value;
                                        }
                                        if (value >= 1 && value < 10) {
                                            return Math.round(value * 10) / 10;
                                        }
                                        if (value >= 10 && value < 100) {
                                            return Math.round(value);
                                        }
                                        return value;
                                    }
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `PPE Fit Factor Analysis - Plot ${index + 1}`,
                                font: {
                                    size: 16
                                }
                            },
                            legend: {
                                display: true
                            }
                        }
                    }
                };
                
                // Create the actual Chart.js instance
                const chart = new Chart(ctx, chartConfig);
                
                // Store the chart instance
                charts.push(chart);
                
                // Update plot statistics
                updatePlotStats(index);
            });
        }
        
        function populateModalDropdowns() {
            const persons = [...new Set(availableFiles.map(f => f.person))];
            const masks = [...new Set(availableFiles.map(f => f.mask))];
            const actions = [...new Set(availableFiles.map(f => f.action))];
            
            populateModalSelect('modalPersonSelect', persons);
            populateModalSelect('modalMaskSelect', masks);
            populateModalSelect('modalActionSelect', actions);
        }
        
        function populateModalSelect(selectId, options) {
            const select = document.getElementById(selectId);
            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }
            
            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                select.appendChild(optionElement);
            });
        }
        
        function clearModalSelections() {
            document.getElementById('modalPersonSelect').selectedIndex = -1;
            document.getElementById('modalMaskSelect').selectedIndex = -1;
            document.getElementById('modalActionSelect').selectedIndex = -1;
        }
        
        function updateModalLinesList() {
            const linesList = document.getElementById('currentLinesList');
            
            if (editingChartIndex === -1 || !charts[editingChartIndex]) {
                linesList.innerHTML = '<div class="empty-lines">No lines in this plot</div>';
                return;
            }
            
            const chart = charts[editingChartIndex];
            linesList.innerHTML = '';
            
            if (chart.data.datasets.length === 0) {
                linesList.innerHTML = '<div class="empty-lines">No lines in this plot</div>';
                return;
            }
            
            chart.data.datasets.forEach((dataset, datasetIndex) => {
                const lineItem = document.createElement('div');
                lineItem.className = 'current-line-item';
                lineItem.style.borderLeftColor = dataset.borderColor;
                
                lineItem.innerHTML = `
                    <div class="current-line-label" title="${dataset.label}">${dataset.label}</div>
                    <button class="current-line-remove" onclick="removeLineFromModal(${datasetIndex})">Remove</button>
                `;
                
                linesList.appendChild(lineItem);
            });
        }
        
        function removeLineFromModal(datasetIndex) {
            if (editingChartIndex === -1 || !charts[editingChartIndex]) return;
            
            const chart = charts[editingChartIndex];
            if (datasetIndex < 0 || datasetIndex >= chart.data.datasets.length) return;
            
            // Remove the dataset
            chart.data.datasets.splice(datasetIndex, 1);
            chart.update();
            
            // Update chart labels to match actual data range
            updateChartLabels(chart);
            
            // Update the modal lines display
            updateModalLinesList();
            updatePlotStats(editingChartIndex);
            
            // Update statistics if no datasets left
            if (chart.data.datasets.length === 0) {
                const statsContainer = document.getElementById('statsContainer');
                statsContainer.style.display = 'none';
            }
        }
        
        function checkModalButtons() {
            const persons = Array.from(document.getElementById('modalPersonSelect').selectedOptions).map(o => o.value).filter(v => v);
            const masks = Array.from(document.getElementById('modalMaskSelect').selectedOptions).map(o => o.value).filter(v => v);
            const actions = Array.from(document.getElementById('modalActionSelect').selectedOptions).map(o => o.value).filter(v => v);
            
            const isDataSelected = persons.length > 0 && masks.length > 0 && actions.length > 0;
            document.getElementById('modalActionButton').disabled = !isDataSelected;
        }
        
        function getModalSelectedValues(selectId) {
            const select = document.getElementById(selectId);
            return Array.from(select.selectedOptions).map(option => option.value).filter(value => value);
        }
        
        async function addLineToEditingPlot() {
            if (editingChartIndex === -1 || !charts[editingChartIndex]) {
                alert('No plot selected for editing');
                return;
            }
            
            try {
                const persons = getModalSelectedValues('modalPersonSelect');
                const masks = getModalSelectedValues('modalMaskSelect');
                const actions = getModalSelectedValues('modalActionSelect');
                
                const currentChart = charts[editingChartIndex];
                
                // Create datasets for all combinations
                for (const person of persons) {
                    for (const mask of masks) {
                        for (const action of actions) {
                            const file = availableFiles.find(f => 
                                f.person === person && f.mask === mask && f.action === action
                            );
                            
                            if (file) {
                                try {
                                    const data = await loadCSVData(file.filename);
                                    const fitFactorValues = data.map(row => parseFloat(row.FitFactor)).filter(val => !isNaN(val));
                                    
                                    if (fitFactorValues.length > 0) {
                                        const colorIndex = currentChart.data.datasets.length % chartColors.length;
                                        
                                        // Add main dataset
                                        const dataset = {
                                            label: `${person} / ${mask} / Action ${action}`,
                                            data: fitFactorValues,
                                            borderColor: chartColors[colorIndex],
                                            backgroundColor: chartColors[colorIndex] + '20',
                                            borderWidth: 2,
                                            fill: false,
                                            tension: 0.1
                                        };
                                        
                                        currentChart.data.datasets.push(dataset);
                                    }
                                } catch (error) {
                                    console.error(`Error loading data for ${person}/${mask}/${action}:`, error);
                                }
                            }
                        }
                    }
                }
                
                currentChart.update();
                updateModalLinesList();
                updatePlotStats(editingChartIndex);
                clearModalSelections();
                checkModalButtons();
                
                // Update chart labels to match actual data range
                updateChartLabels(currentChart);
                
            } catch (error) {
                console.error('Error adding lines to plot:', error);
                alert('Error adding lines to plot: ' + error.message);
            }
        }
        
        // Update Select All functions for modal
        function selectAllPersons() {
            const select = document.getElementById('modalPersonSelect');
            const persons = [...new Set(availableFiles.map(f => f.person))];
            
            // Clear current selections
            for (let option of select.options) {
                option.selected = false;
            }
            
            // Select all person options
            for (let option of select.options) {
                if (persons.includes(option.value)) {
                    option.selected = true;
                }
            }
            
            checkModalButtons();
        }
        
        function selectAllMasks() {
            const select = document.getElementById('modalMaskSelect');
            const masks = [...new Set(availableFiles.map(f => f.mask))];
            
            // Clear current selections
            for (let option of select.options) {
                option.selected = false;
            }
            
            // Select all mask options
            for (let option of select.options) {
                if (masks.includes(option.value)) {
                    option.selected = true;
                }
            }
            
            checkModalButtons();
        }
        
        function selectAllActions() {
            const select = document.getElementById('modalActionSelect');
            const actions = [...new Set(availableFiles.map(f => f.action))];
            
            // Clear current selections
            for (let option of select.options) {
                option.selected = false;
            }
            
            // Select all action options
            for (let option of select.options) {
                if (actions.includes(option.value)) {
                    option.selected = true;
                }
            }
            
            checkModalButtons();
        }
        
        // Remove chart
        function removeChart(index) {
            if (charts[index]) {
                charts[index].destroy();
                charts[index] = null;
            }
            
            const container = document.getElementById(`chartContainer${index}`);
            if (container) {
                container.remove();
            }
            
            // Clean up charts array and update indices
            charts = charts.filter((chart, i) => i !== index);
            
            // Re-render all charts with updated indices
            const plotsContainer = document.getElementById('plotsContainer');
            plotsContainer.innerHTML = '';
            
            charts.forEach((chart, i) => {
                createChartContainer(i);
                // Re-create chart in new container
                const ctx = document.getElementById(`chart${i}`).getContext('2d');
                charts[i] = new Chart(ctx, chart.config);
            });
            
            // Update plus button visibility
            updatePlusButtonVisibility();
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const editModal = document.getElementById('editModal');
            
            if (event.target === editModal) {
                closeEditModal();
            }
        }
        
        // Initialize the application
        async function init() {
            try {
                availableFiles = await getAvailableFiles();
                
                // Add event listeners for modal dropdowns only
                document.getElementById('modalPersonSelect').addEventListener('change', checkModalButtons);
                document.getElementById('modalMaskSelect').addEventListener('change', checkModalButtons);
                document.getElementById('modalActionSelect').addEventListener('change', checkModalButtons);
                
                // Set initial plus button visibility
                updatePlusButtonVisibility();
                
            } catch (error) {
                console.error('Error initializing application:', error);
                alert('Error initializing application: ' + error.message);
            }
        }
        
        // Start the application when the page loads
        window.addEventListener('load', init);
        
        // Manage visibility of plus buttons based on plot count
        function updatePlusButtonVisibility() {
            const emptyStatePlus = document.getElementById('emptyStatePlus');
            const plotsAndAddContainer = document.getElementById('plotsAndAddContainer');
            const plotsPlusButton = document.getElementById('plotsPlusButton');
            
            if (charts.length === 0) {
                // No plots - show empty state plus
                emptyStatePlus.style.display = 'flex';
                plotsAndAddContainer.style.display = 'none';
                plotsPlusButton.style.display = 'none';
            } else {
                // Has plots - show plots container and bottom add button
                emptyStatePlus.style.display = 'none';
                plotsAndAddContainer.style.display = 'block';
                plotsPlusButton.style.display = 'flex';
            }
        }
        
        // Calculate statistics for a specific plot
        function calculatePlotStats(chartIndex) {
            if (chartIndex < 0 || chartIndex >= charts.length || !charts[chartIndex]) {
                return null;
            }
            
            const chart = charts[chartIndex];
            const datasets = chart.data.datasets;
            
            if (datasets.length === 0) {
                return {
                    series: [],
                    totalLines: 0
                };
            }
            
            // Calculate stats for each individual series
            const seriesStats = datasets.map((dataset, index) => {
                const validValues = dataset.data.filter(v => !isNaN(v) && v !== null);
                
                if (validValues.length === 0) {
                    return {
                        label: dataset.label,
                        color: dataset.borderColor,
                        mean: '-',
                        max: '-',
                        min: '-',
                        points: 0
                    };
                }
                
                const mean = validValues.reduce((sum, val) => sum + val, 0) / validValues.length;
                const max = Math.max(...validValues);
                const min = Math.min(...validValues);
                
                return {
                    label: dataset.label,
                    color: dataset.borderColor,
                    mean: mean.toFixed(2),
                    max: max.toFixed(2),
                    min: min.toFixed(2),
                    points: validValues.length
                };
            });
            
            return {
                series: seriesStats,
                totalLines: datasets.length
            };
        }
        
        // Update statistics display for a specific plot
        function updatePlotStats(chartIndex) {
            const stats = calculatePlotStats(chartIndex);
            const container = document.getElementById(`seriesStats${chartIndex}`);
            
            if (!stats || !container) return;
            
            if (stats.series.length === 0) {
                container.innerHTML = '<div class="no-series">No data series</div>';
                return;
            }
            
            container.innerHTML = '';
            
            stats.series.forEach(seriesStat => {
                const seriesItem = document.createElement('div');
                seriesItem.className = 'series-stat-item';
                seriesItem.style.borderLeftColor = seriesStat.color;
                
                seriesItem.innerHTML = `
                    <div class="series-label" title="${seriesStat.label}">${seriesStat.label}</div>
                    <div class="series-stats">
                        <div class="series-stat">
                            <div class="series-stat-value">${seriesStat.mean}</div>
                            <div class="series-stat-label">Mean</div>
                        </div>
                        <div class="series-stat">
                            <div class="series-stat-value">${seriesStat.max}</div>
                            <div class="series-stat-label">Max</div>
                        </div>
                        <div class="series-stat">
                            <div class="series-stat-value">${seriesStat.min}</div>
                            <div class="series-stat-label">Min</div>
                        </div>
                        <div class="series-stat">
                            <div class="series-stat-value">${seriesStat.points}</div>
                            <div class="series-stat-label">Points</div>
                        </div>
                    </div>
                `;
                
                container.appendChild(seriesItem);
            });
        }
        
        // Open chart in full screen (new tab)
        function openFullScreen(chartIndex) {
            if (chartIndex < 0 || chartIndex >= charts.length || !charts[chartIndex]) {
                return;
            }
            
            const chart = charts[chartIndex];
            
            // Create a clean copy of chart data without circular references
            const cleanChartData = {
                labels: [...chart.data.labels],
                datasets: chart.data.datasets.map(dataset => ({
                    label: dataset.label,
                    data: [...dataset.data],
                    borderColor: dataset.borderColor,
                    backgroundColor: dataset.backgroundColor,
                    borderWidth: dataset.borderWidth,
                    fill: dataset.fill,
                    tension: dataset.tension
                }))
            };
            
            // Open new tab and write content
            const newTab = window.open();
            newTab.document.write('<!DOCTYPE html>');
            newTab.document.write('<html lang="en">');
            newTab.document.write('<head>');
            newTab.document.write('<meta charset="UTF-8">');
            newTab.document.write('<meta name="viewport" content="width=device-width, initial-scale=1.0">');
            newTab.document.write('<title>PPE Fit Factor Analysis - Plot ' + (chartIndex + 1) + '</title>');
            newTab.document.write('<script src="https://cdn.jsdelivr.net/npm/chart.js"><\/script>');
            newTab.document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"><\/script>');
            
            // Add comprehensive CSS
            newTab.document.write('<style>');
            newTab.document.write('body{margin:0;padding:20px;font-family:"Segoe UI",Tahoma,Geneva,Verdana,sans-serif;background-color:#f5f5f5}');
            newTab.document.write('.container{width:100%;height:calc(100vh - 40px);background-color:white;border-radius:10px;box-shadow:0 4px 6px rgba(0,0,0,0.1);padding:30px;box-sizing:border-box}');
            newTab.document.write('.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}');
            newTab.document.write('h1{color:#333;margin:0}');
            newTab.document.write('.controls{display:flex;gap:10px}');
            newTab.document.write('.btn{padding:8px 16px;border:none;border-radius:5px;cursor:pointer;font-size:14px;font-weight:bold;transition:background-color 0.3s}');
            newTab.document.write('.btn-success{background-color:#28a745;color:white}.btn-success:hover{background-color:#218838}');
            newTab.document.write('.btn-secondary{background-color:#6c757d;color:white}.btn-secondary:hover{background-color:#5a6268}');
            newTab.document.write('.btn-info{background-color:#17a2b8;color:white}.btn-info:hover{background-color:#138496}');
            newTab.document.write('.btn-danger{background-color:#dc3545;color:white}.btn-danger:hover{background-color:#c82333}');
            newTab.document.write('.chart-container{width:100%;height:calc(100% - 80px);position:relative}');
            
            // Modal CSS
            newTab.document.write('.modal{display:none;position:fixed;z-index:2000;left:0;top:0;width:100%;height:100%;background-color:rgba(0,0,0,0.5);backdrop-filter:blur(3px)}');
            newTab.document.write('.modal-content{background-color:white;margin:5% auto;padding:30px;border-radius:12px;width:90%;max-width:700px;max-height:80vh;overflow-y:auto;box-shadow:0 10px 30px rgba(0,0,0,0.3);position:relative}');
            newTab.document.write('.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:25px;padding-bottom:15px;border-bottom:2px solid #e9ecef}');
            newTab.document.write('.modal-title{font-size:1.5em;font-weight:bold;color:#333}');
            newTab.document.write('.modal-close{background:none;border:none;font-size:30px;color:#999;cursor:pointer;padding:0;width:40px;height:40px;display:flex;align-items:center;justify-content:center;border-radius:50%;transition:all 0.3s}.modal-close:hover{background-color:#f8f9fa;color:#333}');
            newTab.document.write('.modal-section{margin-bottom:25px}.modal-section h4{margin:0 0 15px 0;color:#555;font-size:1.1em}');
            newTab.document.write('.controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:20px;margin-bottom:20px}');
            newTab.document.write('.control-group{display:flex;flex-direction:column;align-items:center;background-color:white;padding:15px;border-radius:8px;border:1px solid #dee2e6}');
            newTab.document.write('.select-all-btn{background-color:#17a2b8;color:white;padding:4px 8px;border:none;border-radius:3px;cursor:pointer;font-size:11px;font-weight:bold;margin-bottom:8px;transition:background-color 0.3s}.select-all-btn:hover{background-color:#138496}');
            newTab.document.write('label{font-weight:bold;margin-bottom:8px;color:#555;font-size:14px}');
            newTab.document.write('select{padding:8px;border:2px solid #ddd;border-radius:5px;font-size:14px;width:100%;max-width:180px;background-color:white;min-height:100px}');
            newTab.document.write('select[multiple]{min-height:120px}select option:checked{background-color:#4CAF50;color:white}');
            newTab.document.write('.current-lines-list{max-height:200px;overflow-y:auto;border:1px solid #e9ecef;border-radius:8px;padding:10px;background-color:#f8f9fa}');
            newTab.document.write('.current-line-item{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;margin:4px 0;background-color:white;border-radius:6px;border-left:4px solid;font-size:14px;box-shadow:0 1px 3px rgba(0,0,0,0.1);flex-wrap:wrap;gap:8px}');
            newTab.document.write('.current-line-label{flex-grow:1;margin-right:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;min-width:200px}');
            newTab.document.write('.current-line-remove{background-color:#dc3545;color:white;border:none;border-radius:4px;padding:4px 8px;font-size:12px;cursor:pointer;flex-shrink:0;transition:background-color 0.3s}.current-line-remove:hover{background-color:#c82333}');
            newTab.document.write('.empty-lines{text-align:center;color:#999;font-style:italic;padding:20px}');
            newTab.document.write('kbd{background-color:#f9f9f9;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 1px rgba(0,0,0,0.2);color:#333;display:inline-block;font-family:Arial,sans-serif;font-size:0.85em;font-weight:bold;line-height:1;padding:2px 4px;white-space:nowrap}');
            newTab.document.write('.control-row{display:flex;align-items:center;gap:15px;margin-bottom:15px;flex-wrap:wrap;justify-content:center}');
            newTab.document.write('</style>');
            
            newTab.document.write('</head>');
            newTab.document.write('<body>');
            newTab.document.write('<div class="container">');
            newTab.document.write('<div class="header">');
            newTab.document.write('<h1>PPE Fit Factor Analysis - Plot ' + (chartIndex + 1) + '</h1>');
            newTab.document.write('<div class="controls">');
            newTab.document.write('<button class="btn btn-success" onclick="downloadChart()" title="Download Chart">‚¨á Download</button>');
            newTab.document.write('<button class="btn btn-secondary" onclick="openEditModal()" title="Edit Plot">‚úèÔ∏è Edit</button>');
            newTab.document.write('</div>');
            newTab.document.write('</div>');
            newTab.document.write('<div class="chart-container">');
            newTab.document.write('<canvas id="fullScreenChart"></canvas>');
            newTab.document.write('</div>');
            newTab.document.write('</div>');
            
            // Add modal HTML
            newTab.document.write('<div id="editModal" class="modal">');
            newTab.document.write('<div class="modal-content">');
            newTab.document.write('<div class="modal-header">');
            newTab.document.write('<div class="modal-title">Edit Plot ' + (chartIndex + 1) + '</div>');
            newTab.document.write('<button class="modal-close" onclick="closeEditModal()">&times;</button>');
            newTab.document.write('</div>');
            newTab.document.write('<div class="modal-section">');
            newTab.document.write('<h4>Current Lines</h4>');
            newTab.document.write('<div class="current-lines-list" id="currentLinesList">');
            newTab.document.write('<div class="empty-lines">No lines in this plot</div>');
            newTab.document.write('</div>');
            newTab.document.write('</div>');
            newTab.document.write('<div class="modal-section">');
            newTab.document.write('<h4>Add New Lines</h4>');
            newTab.document.write('<div style="background-color: #e8f4fd; padding: 12px; border-radius: 6px; margin-bottom: 20px; border-left: 4px solid #2196F3;">');
            newTab.document.write('<p style="margin: 0; font-size: 14px; color: #1976D2;">');
            newTab.document.write('<strong>üí° How to select multiple items:</strong><br>');
            newTab.document.write('‚Ä¢ Hold <kbd>Ctrl</kbd> (Windows/Linux) or <kbd>Cmd</kbd> (Mac) and click to select multiple individual items<br>');
            newTab.document.write('‚Ä¢ Use "Select All" buttons for quick selection of all options<br>');
            newTab.document.write('‚Ä¢ You can mix and match selections from different categories');
            newTab.document.write('</p>');
            newTab.document.write('</div>');
            newTab.document.write('<div class="controls">');
            newTab.document.write('<div class="control-group">');
            newTab.document.write('<button class="select-all-btn" onclick="selectAllPersons()">Select All Persons</button>');
            newTab.document.write('<label for="modalPersonSelect">Person:</label>');
            newTab.document.write('<select id="modalPersonSelect" multiple>');
            newTab.document.write('<option value="">Select Person</option>');
            newTab.document.write('</select>');
            newTab.document.write('</div>');
            newTab.document.write('<div class="control-group">');
            newTab.document.write('<button class="select-all-btn" onclick="selectAllMasks()">Select All Masks</button>');
            newTab.document.write('<label for="modalMaskSelect">Mask:</label>');
            newTab.document.write('<select id="modalMaskSelect" multiple>');
            newTab.document.write('<option value="">Select Mask</option>');
            newTab.document.write('</select>');
            newTab.document.write('</div>');
            newTab.document.write('<div class="control-group">');
            newTab.document.write('<button class="select-all-btn" onclick="selectAllActions()">Select All Actions</button>');
            newTab.document.write('<label for="modalActionSelect">Action:</label>');
            newTab.document.write('<select id="modalActionSelect" multiple>');
            newTab.document.write('<option value="">Select Action</option>');
            newTab.document.write('</select>');
            newTab.document.write('</div>');
            newTab.document.write('</div>');
            newTab.document.write('<div class="control-row">');
            newTab.document.write('<button id="modalActionButton" onclick="addLineToPlot()" disabled>Add Lines to Plot</button>');
            newTab.document.write('</div>');
            newTab.document.write('</div>');
            newTab.document.write('</div>');
            newTab.document.write('</div>');
            
            // Add comprehensive JavaScript
            newTab.document.write('<script>');
            newTab.document.write('const chartData = ' + JSON.stringify(cleanChartData) + ';');
            newTab.document.write('let fullScreenChart;');
            newTab.document.write('let availableFiles = ' + JSON.stringify(availableFiles) + ';');
            newTab.document.write('let chartColors = ["#4CAF50", "#2196F3", "#FF9800", "#9C27B0", "#F44336", "#00BCD4", "#FFEB3B", "#795548", "#607D8B", "#E91E63"];');
            
            // Chart initialization
            newTab.document.write('document.addEventListener("DOMContentLoaded", function() {');
            newTab.document.write('try {');
            newTab.document.write('const ctx = document.getElementById("fullScreenChart").getContext("2d");');
            newTab.document.write('let actualMaxLength = 0;');
            newTab.document.write('chartData.datasets.forEach(dataset => {');
            newTab.document.write('if (dataset.data && dataset.data.length > actualMaxLength) {');
            newTab.document.write('actualMaxLength = dataset.data.length;');
            newTab.document.write('}');
            newTab.document.write('});');
            newTab.document.write('chartData.labels = Array.from({length: actualMaxLength}, (_, i) => i + 1);');
            newTab.document.write('fullScreenChart = new Chart(ctx, {');
            newTab.document.write('type: "line",');
            newTab.document.write('data: chartData,');
            newTab.document.write('options: {');
            newTab.document.write('responsive: true,');
            newTab.document.write('maintainAspectRatio: false,');
            newTab.document.write('scales: {');
            newTab.document.write('x: { title: { display: true, text: "Data Point" } },');
            newTab.document.write('y: { type: "logarithmic", title: { display: true, text: "Fit Factor (Log Scale)" }, min: 1, ticks: { callback: function(value) { if (value === 1 || value === 10 || value === 100 || value === 1000) return value; if (value >= 1 && value < 10) return Math.round(value * 10) / 10; if (value >= 10 && value < 100) return Math.round(value); return value; } } }');
            newTab.document.write('},');
            newTab.document.write('plugins: {');
            newTab.document.write('title: { display: true, text: "PPE Fit Factor Analysis - Plot ' + (chartIndex + 1) + '", font: { size: 20 } },');
            newTab.document.write('legend: { display: true }');
            newTab.document.write('}');
            newTab.document.write('}');
            newTab.document.write('});');
            newTab.document.write('} catch (error) {');
            newTab.document.write('console.error("Error creating chart:", error);');
            newTab.document.write('document.getElementById("fullScreenChart").parentElement.innerHTML = "<p>Error loading chart: " + error.message + "</p>";');
            newTab.document.write('}');
            newTab.document.write('});');
            
            // Add all necessary functions
            newTab.document.write('function downloadChart() {');
            newTab.document.write('const url = fullScreenChart.toBase64Image("image/png", 1.0);');
            newTab.document.write('const link = document.createElement("a");');
            newTab.document.write('link.download = "ppe_plot_' + (chartIndex + 1) + '.png";');
            newTab.document.write('link.href = url;');
            newTab.document.write('document.body.appendChild(link);');
            newTab.document.write('link.click();');
            newTab.document.write('document.body.removeChild(link);');
            newTab.document.write('}');
            
            // Modal functions
            newTab.document.write('function openEditModal() {');
            newTab.document.write('const modal = document.getElementById("editModal");');
            newTab.document.write('populateModalDropdowns();');
            newTab.document.write('updateModalLinesList();');
            newTab.document.write('modal.style.display = "block";');
            newTab.document.write('clearModalSelections();');
            newTab.document.write('checkModalButtons();');
            newTab.document.write('}');
            
            newTab.document.write('function closeEditModal() {');
            newTab.document.write('const modal = document.getElementById("editModal");');
            newTab.document.write('modal.style.display = "none";');
            newTab.document.write('}');
            
            // CSV loading function
            newTab.document.write('async function loadCSVData(filename) {');
            newTab.document.write('try {');
            newTab.document.write('const response = await fetch("Data/" + filename);');
            newTab.document.write('if (!response.ok) throw new Error("HTTP error! status: " + response.status);');
            newTab.document.write('const csvText = await response.text();');
            newTab.document.write('return new Promise((resolve, reject) => {');
            newTab.document.write('Papa.parse(csvText, {');
            newTab.document.write('header: true,');
            newTab.document.write('skipEmptyLines: true,');
            newTab.document.write('complete: function(results) { resolve(results.data); },');
            newTab.document.write('error: function(error) { reject(error); }');
            newTab.document.write('});');
            newTab.document.write('});');
            newTab.document.write('} catch (error) {');
            newTab.document.write('console.error("Error loading CSV:", error);');
            newTab.document.write('throw error;');
            newTab.document.write('}');
            newTab.document.write('}');
            
            // Dropdown population
            newTab.document.write('function populateModalDropdowns() {');
            newTab.document.write('const persons = [...new Set(availableFiles.map(f => f.person))];');
            newTab.document.write('const masks = [...new Set(availableFiles.map(f => f.mask))];');
            newTab.document.write('const actions = [...new Set(availableFiles.map(f => f.action))];');
            newTab.document.write('populateModalSelect("modalPersonSelect", persons);');
            newTab.document.write('populateModalSelect("modalMaskSelect", masks);');
            newTab.document.write('populateModalSelect("modalActionSelect", actions);');
            newTab.document.write('}');
            
            newTab.document.write('function populateModalSelect(selectId, options) {');
            newTab.document.write('const select = document.getElementById(selectId);');
            newTab.document.write('while (select.children.length > 1) select.removeChild(select.lastChild);');
            newTab.document.write('options.forEach(option => {');
            newTab.document.write('const optionElement = document.createElement("option");');
            newTab.document.write('optionElement.value = option;');
            newTab.document.write('optionElement.textContent = option;');
            newTab.document.write('select.appendChild(optionElement);');
            newTab.document.write('});');
            newTab.document.write('}');
            
            // Modal helper functions
            newTab.document.write('function clearModalSelections() {');
            newTab.document.write('document.getElementById("modalPersonSelect").selectedIndex = -1;');
            newTab.document.write('document.getElementById("modalMaskSelect").selectedIndex = -1;');
            newTab.document.write('document.getElementById("modalActionSelect").selectedIndex = -1;');
            newTab.document.write('}');
            
            newTab.document.write('function updateModalLinesList() {');
            newTab.document.write('const linesList = document.getElementById("currentLinesList");');
            newTab.document.write('linesList.innerHTML = "";');
            newTab.document.write('if (fullScreenChart.data.datasets.length === 0) {');
            newTab.document.write('linesList.innerHTML = \'<div class="empty-lines">No lines in this plot</div>\';');
            newTab.document.write('return;');
            newTab.document.write('}');
            newTab.document.write('fullScreenChart.data.datasets.forEach((dataset, datasetIndex) => {');
            newTab.document.write('const lineItem = document.createElement("div");');
            newTab.document.write('lineItem.className = "current-line-item";');
            newTab.document.write('lineItem.style.borderLeftColor = dataset.borderColor;');
            newTab.document.write('lineItem.innerHTML = `<div class="current-line-label" title="${dataset.label}">${dataset.label}</div><button class="current-line-remove" onclick="removeLineFromModal(${datasetIndex})">Remove</button>`;');
            newTab.document.write('linesList.appendChild(lineItem);');
            newTab.document.write('});');
            newTab.document.write('}');
            
            newTab.document.write('function removeLineFromModal(datasetIndex) {');
            newTab.document.write('if (datasetIndex < 0 || datasetIndex >= fullScreenChart.data.datasets.length) return;');
            newTab.document.write('fullScreenChart.data.datasets.splice(datasetIndex, 1);');
            newTab.document.write('fullScreenChart.update();');
            newTab.document.write('updateChartLabels(fullScreenChart);');
            newTab.document.write('updateModalLinesList();');
            newTab.document.write('clearModalSelections();');
            newTab.document.write('checkModalButtons();');
            newTab.document.write('}');
            
            newTab.document.write('function updateChartLabels(chart) {');
            newTab.document.write('if (!chart || !chart.data || !chart.data.datasets) return;');
            newTab.document.write('let actualMaxLength = 0;');
            newTab.document.write('chart.data.datasets.forEach(dataset => {');
            newTab.document.write('if (dataset.data && dataset.data.length > actualMaxLength) {');
            newTab.document.write('actualMaxLength = dataset.data.length;');
            newTab.document.write('}');
            newTab.document.write('});');
            newTab.document.write('if (actualMaxLength > 0) {');
            newTab.document.write('chart.data.labels = Array.from({length: actualMaxLength}, (_, i) => i + 1);');
            newTab.document.write('chart.update();');
            newTab.document.write('}');
            newTab.document.write('}');
            
            newTab.document.write('function checkModalButtons() {');
            newTab.document.write('const persons = Array.from(document.getElementById("modalPersonSelect").selectedOptions).map(o => o.value).filter(v => v);');
            newTab.document.write('const masks = Array.from(document.getElementById("modalMaskSelect").selectedOptions).map(o => o.value).filter(v => v);');
            newTab.document.write('const actions = Array.from(document.getElementById("modalActionSelect").selectedOptions).map(o => o.value).filter(v => v);');
            newTab.document.write('const isDataSelected = persons.length > 0 && masks.length > 0 && actions.length > 0;');
            newTab.document.write('document.getElementById("modalActionButton").disabled = !isDataSelected;');
            newTab.document.write('}');
            
            newTab.document.write('function getModalSelectedValues(selectId) {');
            newTab.document.write('const select = document.getElementById(selectId);');
            newTab.document.write('return Array.from(select.selectedOptions).map(option => option.value).filter(value => value);');
            newTab.document.write('}');
            
            // Select all functions
            newTab.document.write('function selectAllPersons() {');
            newTab.document.write('const select = document.getElementById("modalPersonSelect");');
            newTab.document.write('const persons = [...new Set(availableFiles.map(f => f.person))];');
            newTab.document.write('for (let option of select.options) option.selected = false;');
            newTab.document.write('for (let option of select.options) { if (persons.includes(option.value)) option.selected = true; }');
            newTab.document.write('checkModalButtons();');
            newTab.document.write('}');
            
            newTab.document.write('function selectAllMasks() {');
            newTab.document.write('const select = document.getElementById("modalMaskSelect");');
            newTab.document.write('const masks = [...new Set(availableFiles.map(f => f.mask))];');
            newTab.document.write('for (let option of select.options) option.selected = false;');
            newTab.document.write('for (let option of select.options) { if (masks.includes(option.value)) option.selected = true; }');
            newTab.document.write('checkModalButtons();');
            newTab.document.write('}');
            
            newTab.document.write('function selectAllActions() {');
            newTab.document.write('const select = document.getElementById("modalActionSelect");');
            newTab.document.write('const actions = [...new Set(availableFiles.map(f => f.action))];');
            newTab.document.write('for (let option of select.options) option.selected = false;');
            newTab.document.write('for (let option of select.options) { if (actions.includes(option.value)) option.selected = true; }');
            newTab.document.write('checkModalButtons();');
            newTab.document.write('}');
            
            // Add line to plot function
            newTab.document.write('async function addLineToPlot() {');
            newTab.document.write('try {');
            newTab.document.write('const persons = getModalSelectedValues("modalPersonSelect");');
            newTab.document.write('const masks = getModalSelectedValues("modalMaskSelect");');
            newTab.document.write('const actions = getModalSelectedValues("modalActionSelect");');
            newTab.document.write('for (const person of persons) {');
            newTab.document.write('for (const mask of masks) {');
            newTab.document.write('for (const action of actions) {');
            newTab.document.write('const file = availableFiles.find(f => f.person === person && f.mask === mask && f.action === action);');
            newTab.document.write('if (file) {');
            newTab.document.write('try {');
            newTab.document.write('const data = await loadCSVData(file.filename);');
            newTab.document.write('const fitFactorValues = data.map(row => {');
            newTab.document.write('let fitFactorValue = row.FitFactor || row["Fit Factor"] || row.fitfactor;');
            newTab.document.write('if (typeof fitFactorValue === "string") fitFactorValue = fitFactorValue.trim();');
            newTab.document.write('const numValue = parseFloat(fitFactorValue);');
            newTab.document.write('return isNaN(numValue) ? null : numValue;');
            newTab.document.write('}).filter(val => val !== null);');
            newTab.document.write('if (fitFactorValues.length > 0) {');
            newTab.document.write('const colorIndex = fullScreenChart.data.datasets.length % chartColors.length;');
            newTab.document.write('const dataset = {');
            newTab.document.write('label: `${person} / ${mask} / Action ${action}`,');
            newTab.document.write('data: fitFactorValues,');
            newTab.document.write('borderColor: chartColors[colorIndex],');
            newTab.document.write('backgroundColor: chartColors[colorIndex] + "20",');
            newTab.document.write('borderWidth: 2,');
            newTab.document.write('fill: false,');
            newTab.document.write('tension: 0.1');
            newTab.document.write('};');
            newTab.document.write('fullScreenChart.data.datasets.push(dataset);');
            newTab.document.write('}');
            newTab.document.write('} catch (error) {');
            newTab.document.write('console.error(`Error loading data for ${person}/${mask}/${action}:`, error);');
            newTab.document.write('}');
            newTab.document.write('}');
            newTab.document.write('}');
            newTab.document.write('fullScreenChart.update();');
            newTab.document.write('updateChartLabels(fullScreenChart);');
            newTab.document.write('updateModalLinesList();');
            newTab.document.write('clearModalSelections();');
            newTab.document.write('checkModalButtons();');
            newTab.document.write('} catch (error) {');
            newTab.document.write('console.error("Error adding lines to plot:", error);');
            newTab.document.write('alert("Error adding lines to plot: " + error.message);');
            newTab.document.write('}');
            newTab.document.write('}');
            
            // Event listeners
            newTab.document.write('document.getElementById("modalPersonSelect").addEventListener("change", checkModalButtons);');
            newTab.document.write('document.getElementById("modalMaskSelect").addEventListener("change", checkModalButtons);');
            newTab.document.write('document.getElementById("modalActionSelect").addEventListener("change", checkModalButtons);');
            
            // Close modal when clicking outside
            newTab.document.write('window.onclick = function(event) {');
            newTab.document.write('const editModal = document.getElementById("editModal");');
            newTab.document.write('if (event.target === editModal) closeEditModal();');
            newTab.document.write('};');
            
            newTab.document.write('<\/script>');
            newTab.document.write('</body>');
            newTab.document.write('</html>');
            newTab.document.close();
        }
        
        // Download chart as image
        function downloadChart(chartIndex) {
            if (chartIndex < 0 || chartIndex >= charts.length || !charts[chartIndex]) {
                return;
            }
            
            const chart = charts[chartIndex];
            
            // Get the chart canvas as an image
            const url = chart.toBase64Image('image/png', 1.0);
            
            // Create a temporary anchor element to trigger download
            const link = document.createElement('a');
            link.download = `ppe_plot_${chartIndex + 1}.png`;
            link.href = url;
            
            // Trigger the download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Save current configuration as YAML
        function saveConfig() {
            if (charts.length === 0) {
                alert('No plots to save');
                return;
            }
            
            // Build configuration object
            const config = {
                plots: []
            };
            
            charts.forEach((chart, index) => {
                const plotConfig = {
                    [`plot_${index + 1}`]: {
                        datasets: []
                    }
                };
                
                // Extract dataset information from chart
                chart.data.datasets.forEach(dataset => {
                    // Parse the label to extract person, mask, and action
                    // Label format: "Person / Mask / Action X"
                    const labelParts = dataset.label.split(' / ');
                    if (labelParts.length === 3) {
                        const person = labelParts[0].trim();
                        const mask = labelParts[1].trim();
                        const actionPart = labelParts[2].trim(); // "Action X"
                        const action = actionPart.replace('Action ', '').trim();
                        
                        plotConfig[`plot_${index + 1}`].datasets.push({
                            person: person,
                            mask: mask,
                            action: action
                        });
                    }
                });
                
                config.plots.push(plotConfig);
            });
            
            // Convert to YAML format (simple implementation)
            let yamlContent = 'plots:\n';
            config.plots.forEach((plot, index) => {
                const plotKey = Object.keys(plot)[0];
                yamlContent += `  - ${plotKey}:\n`;
                yamlContent += `      datasets:\n`;
                plot[plotKey].datasets.forEach(dataset => {
                    yamlContent += `        - person: "${dataset.person}"\n`;
                    yamlContent += `          mask: "${dataset.mask}"\n`;
                    yamlContent += `          action: "${dataset.action}"\n`;
                });
            });
            
            // Create and download file
            const blob = new Blob([yamlContent], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `ppe_config_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.yml`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
        
        // Trigger file input for loading configuration
        function triggerLoadConfig() {
            document.getElementById('configFileInput').click();
        }
        
        // Load configuration from YAML file
        async function loadConfig(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const yamlContent = await file.text();
                
                // Simple YAML parser for our specific format
                const config = parseSimpleYAML(yamlContent);
                
                if (!config.plots || !Array.isArray(config.plots)) {
                    throw new Error('Invalid configuration format');
                }
                
                // Clear existing charts
                charts.forEach(chart => {
                    if (chart && typeof chart.destroy === 'function') {
                        chart.destroy();
                    }
                });
                charts = [];
                document.getElementById('plotsContainer').innerHTML = '';
                
                // Recreate plots from configuration
                for (const plotConfig of config.plots) {
                    const plotKey = Object.keys(plotConfig)[0];
                    const datasets = plotConfig[plotKey].datasets;
                    
                    if (datasets && datasets.length > 0) {
                        await createPlotFromConfig(datasets);
                    }
                }
                
                // Update visibility
                updatePlusButtonVisibility();
                
                // Reset file input
                event.target.value = '';
                
            } catch (error) {
                console.error('Error loading configuration:', error);
                alert('Error loading configuration: ' + error.message);
            }
        }
        
        // Simple YAML parser for our specific format
        function parseSimpleYAML(yamlContent) {
            const lines = yamlContent.split('\n');
            const config = { plots: [] };
            let currentPlot = null;
            let currentDataset = null;
            
            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#')) continue;
                
                if (trimmed === 'plots:') continue;
                
                if (trimmed.startsWith('- plot_')) {
                    if (currentPlot) {
                        config.plots.push(currentPlot);
                    }
                    const plotName = trimmed.replace('- ', '').replace(':', '');
                    currentPlot = {};
                    currentPlot[plotName] = { datasets: [] };
                    continue;
                }
                
                if (trimmed === 'datasets:') continue;
                
                if (trimmed.startsWith('- person:')) {
                    if (currentDataset && currentPlot) {
                        const plotKey = Object.keys(currentPlot)[0];
                        currentPlot[plotKey].datasets.push(currentDataset);
                    }
                    currentDataset = {};
                    currentDataset.person = trimmed.replace('- person:', '').replace(/"/g, '').trim();
                    continue;
                }
                
                if (trimmed.startsWith('mask:')) {
                    if (currentDataset) {
                        currentDataset.mask = trimmed.replace('mask:', '').replace(/"/g, '').trim();
                    }
                    continue;
                }
                
                if (trimmed.startsWith('action:')) {
                    if (currentDataset) {
                        currentDataset.action = trimmed.replace('action:', '').replace(/"/g, '').trim();
                    }
                    continue;
                }
            }
            
            // Add the last dataset and plot
            if (currentDataset && currentPlot) {
                const plotKey = Object.keys(currentPlot)[0];
                currentPlot[plotKey].datasets.push(currentDataset);
            }
            if (currentPlot) {
                config.plots.push(currentPlot);
            }
            
            return config;
        }
        
        // Create a plot from configuration data
        async function createPlotFromConfig(datasets) {
            try {
                const chartDatasets = [];
                let maxLength = 0;
                
                // Create datasets for the plot
                for (const datasetConfig of datasets) {
                    const { person, mask, action } = datasetConfig;
                    
                    const file = availableFiles.find(f => 
                        f.person === person && f.mask === mask && f.action === action
                    );
                    
                    if (file) {
                        try {
                            const data = await loadCSVData(file.filename);
                            
                            // More robust data extraction
                            const fitFactorValues = data.map(row => {
                                let fitFactorValue = row.FitFactor || row['Fit Factor'] || row.fitfactor;
                                
                                if (typeof fitFactorValue === 'string') {
                                    fitFactorValue = fitFactorValue.trim();
                                }
                                
                                const numValue = parseFloat(fitFactorValue);
                                return isNaN(numValue) ? null : numValue;
                            }).filter(val => val !== null);
                            
                            if (fitFactorValues.length > 0) {
                                maxLength = Math.max(maxLength, fitFactorValues.length);
                                
                                const colorIndex = chartDatasets.length % chartColors.length;
                                const color = chartColors[colorIndex];
                                
                                chartDatasets.push({
                                    label: `${person} / ${mask} / Action ${action}`,
                                    data: fitFactorValues,
                                    borderColor: color,
                                    backgroundColor: color + '20',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.1
                                });
                            }
                        } catch (error) {
                            console.error(`Error loading data for ${person}/${mask}/${action}:`, error);
                        }
                    }
                }
                
                if (chartDatasets.length === 0) {
                    console.warn('No valid data found for configuration datasets');
                    return;
                }
                
                // Calculate actual data range needed
                let actualMaxLength = 0;
                chartDatasets.forEach(dataset => {
                    if (dataset.data.length > actualMaxLength) {
                        actualMaxLength = dataset.data.length;
                    }
                });
                
                // Create timestamps based on actual data range
                const timestamps = Array.from({length: actualMaxLength}, (_, i) => i + 1);
                
                // Get the new chart index
                const newChartIndex = charts.length;
                
                // Create chart container
                createChartContainer(newChartIndex);
                
                // Create chart configuration
                const chartConfig = {
                    type: 'line',
                    data: {
                        labels: timestamps,
                        datasets: chartDatasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Data Point'
                                }
                            },
                            y: {
                                type: 'logarithmic',
                                title: {
                                    display: true,
                                    text: 'Fit Factor (Log Scale)'
                                },
                                min: 1,
                                ticks: {
                                    callback: function(value, index, values) {
                                        if (value === 1 || value === 10 || value === 100 || value === 1000) {
                                            return value;
                                        }
                                        if (value >= 1 && value < 10) {
                                            return Math.round(value * 10) / 10;
                                        }
                                        if (value >= 10 && value < 100) {
                                            return Math.round(value);
                                        }
                                        return value;
                                    }
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `PPE Fit Factor Analysis - Plot ${newChartIndex + 1}`,
                                font: {
                                    size: 16
                                }
                            },
                            legend: {
                                display: true
                            }
                        }
                    }
                };
                
                // Create the Chart.js instance
                const ctx = document.getElementById(`chart${newChartIndex}`).getContext('2d');
                const chart = new Chart(ctx, chartConfig);
                
                // Add the chart to the array
                charts.push(chart);
                
                // Update plot statistics
                updatePlotStats(newChartIndex);
                
            } catch (error) {
                console.error('Error creating plot from configuration:', error);
            }
        }
        
        // Update chart labels to match actual data range
        function updateChartLabels(chart) {
            if (!chart || !chart.data || !chart.data.datasets) return;
            
            let actualMaxLength = 0;
            chart.data.datasets.forEach(dataset => {
                if (dataset.data && dataset.data.length > actualMaxLength) {
                    actualMaxLength = dataset.data.length;
                }
            });
            
            // Update labels to match actual data range
            if (actualMaxLength > 0) {
                chart.data.labels = Array.from({length: actualMaxLength}, (_, i) => i + 1);
                chart.update();
            }
        }
    </script>
</body>
</html> 